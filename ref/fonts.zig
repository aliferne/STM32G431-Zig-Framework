//! Generated by minimax-m2.5.
//! This file is used to test if the binary file,
//! `fonts.bin` is correctly generated by `convert_fonts.py`
//! made also by this llm, and test if `@embedFile` is useful.
//! run by `zig test ref/fonts.zig

/// Font module using @embedFile to load font data from binary file
/// Font data format: 95 ASCII characters (0x20-0x7E), each with 24 u16 values (16x16 bitmap)
///
/// Character order (from fonts.h):
/// Space ' ' (0x20) -> '~' (0x7E), total 95 characters
const std = @import("std");

// Embed the binary font data
const font_data = @embedFile("fonts.bin");

// Font constants
pub const FONT_HEIGHT = 16;
pub const FONT_WIDTH = 16;
pub const FONT_CHAR_COUNT: usize = 95; // Printable ASCII: 0x20 to 0x7E
pub const FONT_VALUES_PER_CHAR: usize = 24; // 16 rows x 16 cols = 256 bits = 16 u16, but stored as 24 values
pub const FONT_TOTAL_VALUES: usize = FONT_CHAR_COUNT * FONT_VALUES_PER_CHAR;

/// Get pointer to font data as u16 slice
pub fn getFontData() []const u16 {
    const ptr: [*]const u16 = @ptrCast(@alignCast(font_data.ptr));
    return ptr[0..FONT_TOTAL_VALUES];
}

/// Get font bitmap for a specific ASCII character
/// char: ASCII character code
/// Returns: pointer to the character's bitmap data (24 u16 values), or null if invalid
pub fn getCharBitmap(char: u8) ?[]const u16 {
    // Only support printable ASCII (0x20 to 0x7E)
    if (char < 0x20 or char > 0x7E) {
        return null;
    }

    const index = char - 0x20; // 0 to 94
    const offset = index * FONT_VALUES_PER_CHAR;

    const data = getFontData();
    return data[offset..(offset + FONT_VALUES_PER_CHAR)];
}

/// Get font bitmap by index (0 to 94)
pub fn getCharBitmapByIndex(index: usize) ?[]const u16 {
    if (index >= FONT_CHAR_COUNT) {
        return null;
    }

    const offset = index * FONT_VALUES_PER_CHAR;
    const data = getFontData();
    return data[offset..(offset + FONT_VALUES_PER_CHAR)];
}

/// Get the ASCII character code by index (0 to 94)
pub fn getCharByIndex(index: usize) ?u8 {
    if (index >= FONT_CHAR_COUNT) {
        return null;
    }
    return 0x20 + @as(u8, @intCast(index));
}

/// Get index by ASCII character code
pub fn getIndexByChar(char: u8) ?usize {
    if (char < 0x20 or char > 0x7E) {
        return null;
    }
    return char - 0x20;
}

/// Print all characters (for debugging)
pub fn printAllChars() void {
    std.debug.print("=== All ASCII Characters (0x20-0x7E) ===\n", .{});
    for (0..FONT_CHAR_COUNT) |i| {
        const char_code = getCharByIndex(i) orelse continue;
        const char_byte: u8 = @intCast(char_code);
        std.debug.print("[{:2}] ASCII {d} (0x{X}) -> offset {}\n", .{ i, char_byte, char_byte, i * FONT_VALUES_PER_CHAR });
    }
}

// Test: Verify font data is loaded
test "font data loaded" {
    // Check that font data is loaded
    try std.testing.expect(font_data.len > 0);

    // Check total size: 2280 u16 values = 4560 bytes
    try std.testing.expectEqual(@as(usize, 4560), font_data.len);

    // Verify total values count
    try std.testing.expectEqual(FONT_TOTAL_VALUES, font_data.len / 2);
}

// Test: Get character by index and verify order
test "character order - first few" {
    // Index 0 -> ' ' (Space, 0x20)
    try std.testing.expectEqual(@as(?u8, 0x20), getCharByIndex(0));

    // Index 1 -> '!' (0x21)
    try std.testing.expectEqual(@as(?u8, 0x21), getCharByIndex(1));

    // Index 2 -> '"' (0x22)
    try std.testing.expectEqual(@as(?u8, 0x22), getCharByIndex(2));

    // Index 3 -> '#' (0x23)
    try std.testing.expectEqual(@as(?u8, 0x23), getCharByIndex(3));

    // Index 4 -> '$' (0x24)
    try std.testing.expectEqual(@as(?u8, 0x24), getCharByIndex(4));
}

// Test: Get character by index - middle
test "character order - middle" {
    // Index 16 -> '0' (0x30)
    try std.testing.expectEqual(@as(?u8, 0x30), getCharByIndex(16));

    // Index 16 -> '0' (0x30)
    try std.testing.expectEqual(@as(?u8, 0x30), getCharByIndex(16));

    // Index 22 -> '6' (0x36)
    try std.testing.expectEqual(@as(?u8, 0x36), getCharByIndex(22));

    // Index 33 -> 'A' (0x41)
    try std.testing.expectEqual(@as(?u8, 0x41), getCharByIndex(33));

    // Index 65 -> 'a' (0x61)
    try std.testing.expectEqual(@as(?u8, 0x61), getCharByIndex(65));
}

// Test: Get character by index - last few
test "character order - last few" {
    // Index 90 -> 'z' (0x7A)
    try std.testing.expectEqual(@as(?u8, 0x7A), getCharByIndex(90));

    // Index 92 -> '|' (0x7C)
    try std.testing.expectEqual(@as(?u8, 0x7C), getCharByIndex(92));

    // Index 94 -> '~' (0x7E)
    try std.testing.expectEqual(@as(?u8, 0x7E), getCharByIndex(94));
}

// Test: Get index by character
test "index by character" {
    // ' ' (0x20) -> index 0
    try std.testing.expectEqual(@as(?usize, 0), getIndexByChar(0x20));

    // 'A' (0x41) -> index 33
    try std.testing.expectEqual(@as(?usize, 33), getIndexByChar(0x41));

    // 'a' (0x61) -> index 65
    try std.testing.expectEqual(@as(?usize, 65), getIndexByChar(0x61));

    // '~' (0x7E) -> index 94
    try std.testing.expectEqual(@as(?usize, 94), getIndexByChar(0x7E));

    // Invalid characters should return null
    try std.testing.expectEqual(@as(?usize, null), getIndexByChar(0x1F));
    try std.testing.expectEqual(@as(?usize, null), getIndexByChar(0x7F));
}

// Test: Get bitmap for valid characters
test "get bitmap for valid characters" {
    // Get 'A' bitmap
    const a_bitmap = getCharBitmap('A');
    try std.testing.expect(a_bitmap != null);
    try std.testing.expectEqual(@as(usize, FONT_VALUES_PER_CHAR), a_bitmap.?.len);

    // Get ' ' (space) bitmap
    const space_bitmap = getCharBitmap(' ');
    try std.testing.expect(space_bitmap != null);
    try std.testing.expectEqual(@as(usize, FONT_VALUES_PER_CHAR), space_bitmap.?.len);

    // Get '~' bitmap
    const tilde_bitmap = getCharBitmap('~');
    try std.testing.expect(tilde_bitmap != null);
    try std.testing.expectEqual(@as(usize, FONT_VALUES_PER_CHAR), tilde_bitmap.?.len);
}

// Test: Get bitmap for invalid characters returns null
test "get bitmap for invalid characters" {
    // Below printable range
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmap(0x1F));
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmap(0x00));

    // Above printable range
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmap(0x7F));
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmap(0xFF));
}

// Test: Get bitmap by index
test "get bitmap by index" {
    // Index 0 -> space
    const bitmap0 = getCharBitmapByIndex(0);
    try std.testing.expect(bitmap0 != null);

    // Index 33 -> 'A'
    const bitmap41 = getCharBitmapByIndex(33);
    try std.testing.expect(bitmap41 != null);

    // Index 94 -> '~'
    const bitmap94 = getCharBitmapByIndex(94);
    try std.testing.expect(bitmap94 != null);

    // Invalid index
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmapByIndex(95));
    try std.testing.expectEqual(@as(?[]const u16, null), getCharBitmapByIndex(100));
}

// Test: Verify space character is all zeros
test "space character is blank" {
    const space_bitmap = getCharBitmap(' ');
    try std.testing.expect(space_bitmap != null);

    // Space should be all zeros
    for (space_bitmap.?) |value| {
        try std.testing.expectEqual(@as(u16, 0), value);
    }
}

// Test: Print character table for verification
test "print character table" {
    std.debug.print("\n=== Character Verification ===\n", .{});
    std.debug.print("Total characters: {}, Values Table for per char: {}\n", .{ FONT_CHAR_COUNT, FONT_VALUES_PER_CHAR });

    // Print first 10 characters
    std.debug.print("\nFirst 10 characters:\n", .{});
    for (0..10) |i| {
        const char_code = getCharByIndex(i).?;
        const char_byte: u8 = @intCast(char_code);
        std.debug.print("  [{:2}] ASCII {:3} (0x{X}) = '{c}'\n", .{ i, char_code, char_code, char_byte });
    }

    // Print 'A', '0', 'a'
    std.debug.print("\nKey characters:\n", .{});
    const a_idx = getIndexByChar('A').?;
    const zero_idx = getIndexByChar('0').?;
    const a_lower_idx = getIndexByChar('a').?;

    std.debug.print("  'A' -> index {}, '0' -> index {}, 'a' -> index {}\n", .{ a_idx, zero_idx, a_lower_idx });

    std.debug.print("\n=== End of Character Table ===\n\n", .{});
}
